\section{Introduction}
%---Web Services Composition Contest

Today the web is quickly expanding and new functionalities and applications, appearing day by day, are heavily increasing its potentialities and ease of use. One of the reasons why this growth is taking place is the possibility to connect and let communicate different existent applications, or better, \textit{services}. Now more than ever, with the wide expansion of portable and web-capable devices, based on different technologies, platforms and hardware, this interconnection among services is not only required, but necessary to create a common ground to build software upon.\\

The interconnection among services can be done through ad-hoc solutions, for example, connecting some preexistent legacy applications to create a new application (perhaps available online or over a company's intranet) or using standard paradigms to wrap existing applications and publish them as services. %SOC 
In the case where the standard paradigm is favored, the implementation of such services also needs an architectural infrastructure style. This architecture precisely defines the three main roles: a) which part of the application is offering the service to the outside world (Service Provider), b) where the service should be published for a public usage (Service Registry) and c) who is the user of the service (Service Client). %SOA
A service implemented following such an architecture and guidelines, where its communication channel is the web, is called \textit{Web Service}.\\ %(cite intoduzione ragionata al mondo dei web serv)

Once, starting from simple applications, several services are put in place, many challenges arise to reach the goal of creating a new application (which can be, recursively, used as basic service to create another application) reusing the existing ones. Some of them are: how to discover the services that are publicly available, how the providers can advertise them, how the services should integrate the usage of resources like files or databases, how they provide secure and private access to authorized users and, eventually, how to define the rules to compose and make collaborate the services together. 
The final result of the interactions among the different services is called \textit{Business Process}, which is widely used in the literature and compares in the acronym of some of the main languages used in the service-oriented applications area.\\

Focusing on the latter aspect, the composition of services, it can be achieved using workflow management applications that simultaneously coordinate different processes, making them execute actions in sequence or in parallel, and joining or forking their results at the right time. %(Intro Ragionata WS)
The two main approaches to workflow management are: Orchestration and Choreography.
Orchestration refers to the %(cite introduzione ragionata al mondo dei web serv, pag 20) 
business process realized by the interaction of several services supervised by a main actor. Choreography, instead, is a more collaborative approach, where each of the services has a specific role in the accomplishment of the business process. Eventually, orchestration produces an executable process, which can be run by an orchestration engine, while choreography produces an abstract business protocol that cannot be executed, but only contains the specification of the publicly available messages exchanged between the services.

\paragraph{The problem}
Many of these services, which can be later interconnected, need to run on portable devices, for which calculation power, available memory and consumption are well known issues. In fact, the composition and orchestration/choreography of a business process is a heavy task, and the majority of workflow engines are made to be run on powerful machines both in terms of computation and memory footprint. Moreover, the deployment of a business process usually requires to know a priori the number of participant devices, and, above all, it requires them to have installed network protocols and tools that are not always included in the typical software package of a mobile device. 
Nonetheless, many business processes are already available written in the de facto standard language for web services orchestration: BPEL (Business Process Execution Language). Although there have been attempts to create light and with low memory footprint engines (\cite{bpelMobileEngineMora,bpelMobileEngineHackmann06sliver:a}), the execution of a BPEL process on a small, portable device, is yet to be convenient.

In opposition, in the last years, other technologies have widely spread and have been optimized for the mobile devices world. One as such is surely Java, which has gained ground thanks to its portability, that completely abstracts the software from the hardware. This makes it easy for software companies to produce reusable software, independently of the device architecture. Moreover, ease of use, the huge amount of available libraries and the large user community, surely play in favor of Java language. 
%There are other approaches used to compose and coordinate services (namely, to create a business process), there are RPC and JAVA RMI.

\paragraph{Objective}
Given the widespread presence over the web of BPEL for service-oriented applications implementation, we analyze the possibility of automatically transforming a BPEL written process in a Java executable routine, with minimum ad-hoc developer's intervention.
Our objective is then to show the feasibility of a semi-automated transformation from a small business process orchestrated with BPEL to the well known and wide spread over mobile devices, Java language. 


%---Other works, our approach and what we achieve
%\subsection{Other works}
% - Other similar works: don't know any yet. \nl
% - Our attempt is to use the M2T techniques to obtain from a BPEL WSs composition a JavaRMI equivalent application \nl
% - Where the limits of our solution are (BPEL subset? Lack of heavy test case? Doesn't work at all?...) \nl
% - Where future work might be leaded \nl


%---Overview of the whole work---
\subsection{Overview of the thesis FIXME}
Section \ref{ServiceOrientedComputing} introduces the Service Oriented domain and its components. It gives a brief overview of the paradigms to create service oriented infrastructures (\ref{SOC&SOA}) and the web service technology (\ref{WebServices}). Later in Subsection \ref{WFManagement} Orchestration and Choreography of services are addressed. Then, it focuses on the technologies we will be working on throughout the whole project: BPEL in \ref{BPEL} and Java RMI in \ref{JavaRMI}. \\
Section \ref{ModelDrivenEngineering} introduces Model Driven Engineering (MDE) and its methodologies. At first (Subsection \ref{MDA}) we have a look to where the Model Driven Architecture (MDA) fits in the MDE picture, then we dig into the possible MDA methods, namely: Model-to-Model and Model-to-Text, both in \ref{m2m&m2t}. Plus, in the same Subsection, we have a general look at meta-modeling (\ref{Meta-modeling}) and to the Eclipse Modeling Framework (\ref{EMF}). To conclude, we have a deep look into the Acceleo code generator technology (\ref{acceleo}), how it works (\ref{AcceleoParametirazion}) and its architecture (\ref{AcceleoArchitecture}). \\
The decisional steps we made to choose our methodological approach to carry out the transformation are explained in Section \ref{MethodApproach}. First we overview the Domain of the transformation \ref{sec:TransfDomain}...
FIXME: to complete after Stefano's corrections

%  \item Proposed approach, MDE, MDA
% \end{itemize}


%Generic stuff
% We intend the word \textit{service} as the one used by the UDDI Oasis consortium \cite{Uddi}, where services are self-contained and modular applications that have Internet-oriented and standard-based interfaces. The given definition of services tightly relates to some of the well known web standards used to implement Web Services (WSs) \cite{DiLorenzo08}.